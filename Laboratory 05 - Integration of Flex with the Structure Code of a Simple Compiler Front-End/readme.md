# Laboratory 04 - Lexical Analysis Tools

The codes were developed by professor JUDSON SANTIAGO where you find [here](https://github.com/JudsonSS/Compiladores/tree/master)

## Modify the project to include

### Integrate the intermediate code generation from [Lab 03](https://github.com/PedroHenrique18/Compilers/tree/main/Laboratory%2003%20-%20Intermediate%20code%20generation) to use the lexical analyzer code generated by FLEX. Taking [Lab 04](https://github.com/PedroHenrique18/Compilers/tree/main/Laboratory%2004%20-%20Lexical%20Analysis%20Tools) as a base

## The Solution

### The lexer.l file was modified to recognize more keywords, operators, and data types.

```c++
%{
// Reconhecedor de uma linguagem simplificada
#include <iostream>
#include "tokens.h"
#include "token.h"
using std::cout;

typedef union { 
    Token* token; 
} YYSTYPE; 

YYSTYPE yylval;

%}

%option noyywrap

delim    [ \t\n]
brancos {delim}+
letra    [A-Za-z]
digito   [0-9]
id       ({letra}|_){letra}*({letra}|{digito}|_)*
num      {digito}+(\.{digito}+)?(E[+-]?{digito}+)?

%%

{brancos}    ; // nenhuma ação e nenhum retorno
main        { yylval.token = new Token(MAIN, yytext); return MAIN; }

int         { yylval.token = new Token(INTEGER, yytext); return INTEGER; }
float       { yylval.token = new Token(FLOATING, yytext); return FLOATING; }
bool        { yylval.token = new Token(BOOLEAN, yytext); return BOOLEAN; }
true        { yylval.token = new Token(TRUE, yytext); return TRUE; }
false       { yylval.token = new Token(FALSE, yytext); return FALSE; }

while       { yylval.token = new Token(WHILE, yytext); return WHILE; }
if          { yylval.token = new Token(IF, yytext); return IF; }
else        { yylval.token = new Token(ELSE, yytext); return ELSE; }
do          { yylval.token = new Token(DO, yytext); return DO; }

{id}        { yylval.token = new Token(ID, yytext); return ID; }
{num}       { if (strchr(yytext, '.') || strchr(yytext, 'E') || strchr(yytext, 'e')) { yylval.token = new Token(FLOATING, yytext); return FLOATING; } else { yylval.token = new Token(INTEGER, yytext); return INTEGER; } }


";"         { yylval.token = new Token(';', yytext); return ';'; } 
"="         { yylval.token = new Token('=', yytext); return '='; }
"+"         { yylval.token = new Token('+', yytext); return '+'; } 
"-"         { yylval.token = new Token('-', yytext); return '-'; } 
"*"         { yylval.token = new Token('*', yytext); return '*'; } 
"/"         { yylval.token = new Token('/', yytext); return '/'; }

"!"         { yylval.token = new Token('!', yytext); return '!'; }
"=="        { yylval.token = new Token(EQ, yytext); return EQ; }
"!="        { yylval.token = new Token(NEQ, yytext); return NEQ; }
"<"         { yylval.token = new Token(LT, yytext); return LT; }
"<="        { yylval.token = new Token(LTE, yytext); return LTE; }
">"         { yylval.token = new Token(GT, yytext); return GT; }
">="        { yylval.token = new Token(GTE, yytext); return GTE; }
"&&"        { yylval.token = new Token(AND, yytext); return AND; }
"||"        { yylval.token = new Token(OR, yytext); return OR; }
"("         {yylval.token = new Token('(', yytext); return '(';}
")"         {yylval.token = new Token(')', yytext); return ')';}
"["         {yylval.token = new Token('[', yytext); return '[';}
"]"         {yylval.token = new Token(']', yytext); return ']';}
"{"         {yylval.token = new Token('{', yytext); return '{';}
"}"         {yylval.token = new Token('}', yytext); return '}';}

.           { cout << yytext << " token invalido!\n"; return *yytext; }
%%

int yywrap() {
    return 1;
}

```

### ```Flex``` stores these ```Token``` objects in the ```yylval.token``` field, which allows the token semantics to be preserved and manipulated by the parser.

```c++
{ yylval.token = new Token(EQ, yytext); return EQ; }
```

### More types of keywords, operators, and data types were added to ```tokens.h``` so the lexical analyzer can identify the tokens.

```c++
enum Tag { ID = 256, INTEGER, FLOATING, BOOLEAN, TRUE, FALSE, MAIN, IF, ELSE, WHILE, DO, OR, AND, EQ, NEQ, LT, LTE, GT, GTE};
```


## Testing the implemented functionalities

```c++
int main()
{
    int i; int j; float v; float x; float a[100]; bool flag;

    flag = true;
    while (flag)
    {
        do
        {
            i = i+1;
        } 
        while (a[i] < v);
        
        do
        {
            j = j-1;
        } 
        while (a[j] > v);
        
        if (i >= j)
            flag = false;
    
        x = a[i]; a[i] = a[j]; a[j] = x;
    }
}
```

### Running the command in the terminal

```bash
tradutor.exe ../Testes/teste4.cpp
```

### Output

```txt
C:\Users\pedro\Desktop\Compilers\Laboratory 05 - Integration of Flex with the 
Structure Code of a Simple Compiler Front-End\build>tradutor.exe ../Testes/teste4.cpp
        flag = true
L4:
        ifFalse flag goto L5
L1:
        t1 = i + 1
        i = t1
        t3 = a[i]
        t2 = t3 < v
        ifTrue t2 goto L1   
L2:
        t4 = j - 1
        j = t4
        t6 = a[j]
        t5 = t6 > v
        ifTrue t5 goto L2   
        t7 = i >= j
        ifFalse t7 goto L3  
        flag = false        
L3:
        t8 = a[i]
        x = t8
        t9 = a[j]
        a[i] = t9
        a[j] = x
        goto L4
L5:
```



